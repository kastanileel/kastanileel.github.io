// Fork from https://www.shadertoy.com/view/DllBDB (my own work)

float sdfPlane( vec3 p, vec4 n ){

  return dot(p,n.xyz) + n.w;
}

float sdfSphere(vec3 p, vec3 center, float radius){

    return length(p - center) - radius;
}

// https://iquilezles.org/articles/palettes/
vec3 palette( in float t)
{
    vec3 a = vec3(.9, .5, .5);
    vec3 b = vec3(.5 , .5 , .5 );
    vec3 c = vec3(2.0 , .5 , .7 );
    vec3 d = vec3(.5 , .2 , 1.0 );
    return a + b*cos( 6.28318*(c*t+d) );
}

float sdfAll(vec3 p){

    float displacement = sin(5.0 * p.x + iTime) * sin(5.0 * p.y + iTime) * sin(5.0 * p.z +iTime) * .35;

    float sdf1 = sdfSphere(p, vec3(.5, 0, 0), .65) + displacement/3.;

    vec3 center = vec3(sin(iTime - 3.1415/2.) * .7 -.2 , 0, 0.);
    float sdf2 = sdfSphere(p, center, .7 + sin(iTime - 3.1415/2.) * .1 )+ displacement/2.6;

    float sdf3 = sdfPlane(p, normalize(vec4(0., 1. , 0., 1.8))) + displacement/30.;


    return min(sdf1, min(sdf2, sdf3));
}

vec3 getNormal(vec3 p){

    vec3 offset = vec3(0.001, 0., 0.);

    float gradientX = sdfAll(p + offset.xyy) - sdfAll(p - offset.xyy);
    float gradientY = sdfAll(p + offset.yxy) - sdfAll(p - offset.yxy);
    float gradientZ = sdfAll(p + offset.yyx) - sdfAll(p - offset.yyx);

    return normalize(vec3(gradientX, gradientY, gradientZ));
}

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{


    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;

    //origin of rays
    const vec3 ro = vec3(0., 1., 5.);
    //normalized direction of rays
    vec3 rd = normalize(vec3(uv, 0.) - ro);

    //light ray
    vec3 lightRay = normalize(vec3(sin(iTime*2.)*0.5,sin(iTime)*1.5,1.));

    vec3 currentRayPos;
    float totalMarchedDist = 0.;

    vec3 color = vec3(0);
    vec3 fog = vec3(0);

    //count marches for outline
    int steps;
    float maxDist = 5.5;

    float lightFinal;

    for(int i = 0; i < 16; i ++)
    {

        steps += 1;

        //march along ray
        currentRayPos = ro + totalMarchedDist * rd;

         if(length(currentRayPos - ro) > maxDist || currentRayPos.y < -1.7)
            steps = -1;

        //smallest distance to closest object
        float distToSDF = sdfAll(currentRayPos);
        //=> distance aided raymarching
        totalMarchedDist += distToSDF;


        if(distToSDF < 0.001){

            vec3 normal = getNormal(currentRayPos);

            //calculate diffuse shading
            float diffuseLight =  0.6 * dot(normal, lightRay);

            //calculate specular shading
            float specularLight = dot(reflect(lightRay,normal), normalize(currentRayPos - ro));
            specularLight = pow(specularLight, 9.);

            //filter light values outside [0.0, 1.0]
            specularLight = max(0.0, specularLight);
            diffuseLight = max(0.0, diffuseLight);

            float ambientLight = 0.2;

            float light =  min(diffuseLight+specularLight, 1.) + 0.2;

            color = palette(iTime/5. +  length(currentRayPos + iTime/4.));
            color *= (light );

            lightFinal = light;
            break;
        }


        float fogFactor = pow(length(currentRayPos - ro), 2.) / 800.;
        fog = vec3(fogFactor, fogFactor, fogFactor);
    }

    // apply fog
    color -= fog;

    fragColor = vec4(color,1.0);

    //break linearity of steps to create better outline effect
    float outlineIntensity = smoothstep(.9, 1., float(steps)/16. );

    float aoo = smoothstep(0.8, 0.9, float(steps)/16.);
    float boo = smoothstep(0.6, 0.9, float(steps)/16.);
    float coo = smoothstep(0.5, 0.9, float(steps)/16.);
    float doo = smoothstep(0.4, 0.9, float(steps)/16.);
    float eoo = smoothstep(0.25, 0.9, float(steps)/16.);

    vec3 col = palette(iTime/5. +  length(currentRayPos + iTime/4.));

    col = vec3(1.6, 0. ,0.8) + vec3(sin(uv.x), cos(uv.y), tan(uv.x)/2.);
    col = col * lightFinal;

    vec3 outlineCol = vec3(0.5, 0.2, 1.) + vec3(sin(uv.x), cos(uv.y), tan(uv.x)/2.);


    //eoo = 0.;
    //doo = 0.;
    //coo = 0.;
    //boo = 0.;
    //aoo = 0.;

    fragColor = mix(vec4(col,1.), vec4(vec3(outlineCol*0.8), 1.), eoo);
    fragColor = mix(fragColor, vec4(vec3(outlineCol*0.7), 1.), doo);
    fragColor = mix(fragColor, vec4(vec3(outlineCol*0.55), 1.), coo);
    fragColor = mix(fragColor, vec4(vec3(outlineCol*0.35), 1.), boo);
    fragColor = mix(fragColor, vec4(vec3(outlineCol*0.2), 1.), aoo);
    fragColor = mix(fragColor, vec4(vec3(0.1 * outlineCol), 1.), outlineIntensity);


    outlineCol = vec3(1., 0.1, .3) - vec3(sin(uv.x), cos(uv.y), tan(uv.x)/2.);


    if(steps == -1)
        fragColor = vec4(outlineCol * abs(length(currentRayPos.xz - vec2(-.0 + sin(iTime/1.)*2.,-5. + sin(iTime/1.)*2.))), 1.);

    // outline effect5
    fragColor = mix(fragColor, vec4(vec3(1.-sin(iTime)/4. - .25, cos(iTime*3.)/8. + .25, sin(iTime*3.)/2. + 1.),1.),outlineIntensity);




}